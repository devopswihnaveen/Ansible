- name: create ec2 and r53 records
  hosts: localhost
  connection: local
  vars:
    sg_id: sg-0e73aab28da27d0a7
    ami_id: ami-0220d79f3f480ecf5
    domain_name: amaravathi.today
    env: dev
    instances:
    - mongodb
    - catalogue
  tasks:
  - name: create ec2 instance
    amazon.aws.ec2_instance:
      instance_type: "t3.micro"
      security_group: "{{ sg_id }}"
      image_id: "{{ ami_id }}"
      name: "{{ item }}-{{ env }}"
      tags:
        Project: ecommerce
        Component: "{{ item }}"
        Environment: "{{ env }}"
        Name: "{{ item }}-{{ env }}"
    loop: "{{ instances }}"
    register: ec2_output
    when: action == "create"

  - name: print the output
    ansible.builtin.debug:
      msg: "{{ ec2_output }}"

  #install boto3 and botocore modules to run the above playbook successfully. These modules are required to interact with AWS services using Ansible. You can install them using pip:
  #pip install boto3 botocore
  #and authenticate to AWS using AWS CLI by running the command aws configure and providing your AWS access key, secret key, region, and output format. This will create a credentials file in your home directory that Ansible will use to authenticate with AWS when running the playbook.

  - name: create r53 records
    amazon.aws.route53:
      state: present
      zone: "{{ domain_name }}"
      record: "{{ item.item }}-{{ env }}.{{ domain_name }}" # mongodb-dev.amaravathi.today
      type: A
      ttl: 1
      value: "{{ item.instances[0].private_ip_address }}" # this will set the value of the A record to the private IP address of the EC2 instance that was created in the previous task. We are using item.instances[0].private_ip_address to access the private IP address of the first instance in the list of instances that were created. Since we are creating one instance for each item in the loop, we can safely assume that there will be only one instance in the list for each item, and we can access it using index 0.
      wait: true
    loop: "{{ ec2_output.results }}"
    when: action == "create" # this condition will ensure that we only create the A records when the action variable is set to "create". This allows us to control when we want to create or delete the resources by simply changing the value of the action variable at the beginning of the playbook. For example, if we want to create the resources, we can set action to "create", and if we want to delete the resources, we can set action to "delete". This way, we can reuse the same playbook for both creating and deleting resources without having to modify the tasks themselves.

  - name: create r53 records
    amazon.aws.route53:
      state: present
      zone: "{{ domain_name }}"
      record: "project-{{ env }}.{{ domain_name }}" # project-dev.amaravathi.today
      type: A
      ttl: 1
      value: "{{ item.instances[0].public_ip_address }}"
      wait: true
    loop: "{{ ec2_output.results }}"
    when: 
     - item.item == "frontend" # this condition will ensure that we only create the A record for the frontend instance with the public IP address. Since the frontend instance is the only one that needs to be accessible from the internet, we will create an A record for it with the public IP address. The other instances (mongodb and catalogue) will only have A records with their private IP addresses since they do not need to be accessible from the internet.
     - action == "create" # this condition will ensure that we only create the A records when the action variable is set to "create". This allows us to control when we want to create or delete the resources by simply changing the value of the action variable at the beginning of the playbook. For example, if we want to create the resources, we can set action to "create", and if we want to delete the resources, we can set action to "delete". This way, we can reuse the same playbook for both creating and deleting resources without having to modify the tasks themselves.

  - name: delete r53 records
    amazon.aws.route53:
      state: absent
      zone: "{{ domain_name }}"
      record: "{{ item.item }}-{{ env }}.{{ domain_name }}"
      type: A
    loop: "{{ ec2_output.results }}"
    when: action == "delete" # this condition will ensure that we only delete the A records when the action variable is set to "delete". This allows us to control when we want to create or delete the resources by simply changing the value of the action variable at the beginning of the playbook. For example, if we want to create the resources, we can set action to "create", and if we want to delete the resources, we can set action to "delete". This way, we can reuse the same playbook for both creating and deleting resources without having to modify the tasks themselves.

  - name: delete ec2 instances
    amazon.aws.ec2_instance:
      state: absent
      instance_ids: "{{ item.instances[0].instance_id }}"
    loop: "{{ ec2_output.results }}"
    when: action == "delete" # this condition will ensure that we only delete the EC2 instances when the action variable is set to "delete". This allows us to control when we want to create or delete the resources by simply changing the value of the action variable at the beginning of the playbook. For example, if we want to create the resources, we can set action to "create", and if we want to delete the resources, we can set action to "delete". This way, we can reuse the same playbook for both creating and deleting resources without having to modify the tasks themselves.